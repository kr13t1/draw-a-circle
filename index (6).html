<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Игра "Нарисуй круг"</title>
<style>
    body {
        font-family: 'Nunito', sans-serif;
        background-color: #f0f0f0;
        color: #333;
        text-align: center;
        margin: 0;
        overflow: hidden;
    }

    h1 {
        margin-top: 20px;
        font-size: 2em;
        color: #2EA692;
        font-weight: bold;
    }

    #game-area {
        position: relative;
        width: 90%;
        height: 60vh;
        margin: 20px auto;
        border: 2px solid #06DDBA;
        border-radius: 10px;
        background-color: #fff;
        touch-action: none;
    }

    #percentage {
        font-size: 3em;
        font-weight: 300;
        color: #009078;
        margin-top: 20px;
        font-family: 'Press Start 2P', cursive;
    }

    #logo {
        position: fixed;
        bottom: 10px;
        left: 10px;
        width: 100px;
        height: auto;
        z-index: 1000;
    }

    @media (max-width: 600px) {
        h1 {
            font-size: 1.5em;
        }

        #game-area {
            height: 50vh;
        }
    }
</style>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>

<h1>Игра "Нарисуй круг"</h1>
<canvas id="game-area"></canvas>
<p>Идеальность: <span id="percentage">0%</span></p>

<img id="logo" src="logo.png" alt="Логотип">

<script>
    const canvas = document.getElementById('game-area');
    const ctx = canvas.getContext('2d');
    const percentageDisplay = document.getElementById('percentage');

    let points = [];
    let isDrawing = false;
    let center = { x: canvas.offsetWidth / 2, y: canvas.offsetHeight / 2 };
    let perfectRadius = 0;
    const maxDeviationForColor = 50; // Максимальное отклонение для градиента цвета

    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    function drawCenter() {
        ctx.beginPath();
        ctx.arc(center.x, center.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 144, 120, 0.3)';
        ctx.fill();
    }

    function startDrawing(clientX, clientY) {
        isDrawing = true;
        points = [];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawCenter();

        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        points.push({ x, y });

        const dx = x - center.x;
        const dy = y - center.y;
        perfectRadius = Math.sqrt(dx * dx + dy * dy);
    }

    function draw(clientX, clientY) {
        if (isDrawing) {
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            points.push({ x, y });

            const dx = x - center.x;
            const dy = y - center.y;
            const currentRadius = Math.sqrt(dx * dx + dy * dy);
            const deviation = Math.abs(currentRadius - perfectRadius);

            // Вычисляем цвет линии в зависимости от отклонения
            const color = getColorForDeviation(deviation);

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 3;
            ctx.shadowColor = color;

            if (points.length > 1) {
                ctx.beginPath();
                ctx.moveTo(points[points.length - 2].x, points[points.length - 2].y);
                ctx.lineTo(x, y);
                ctx.stroke();
            }

            // Обновляем проценты в реальном времени
            calculateCircleQuality();
        }
    }

    function endDrawing() {
        isDrawing = false;
        calculateCircleQuality(); // Финальный расчет процентов
    }

    function calculateCircleQuality() {
        if (points.length < 3) {
            percentageDisplay.textContent = "0%";
            return;
        }

        let totalDeviation = 0;
        points.forEach(point => {
            const dx = point.x - center.x;
            const dy = point.y - center.y;
            const currentRadius = Math.sqrt(dx * dx + dy * dy);
            const deviation = Math.abs(currentRadius - perfectRadius);
            totalDeviation += deviation;
        });

        const averageDeviation = totalDeviation / points.length;

        // расчет процента идеальности
        const maxAllowedDeviation = 30; // Максимальное допустимое отклонение
        const quality = Math.max(0, 100 - (averageDeviation / maxAllowedDeviation) * 100);
        percentageDisplay.textContent = `${Math.round(quality)}%`;
    }

    // Функция для получения цвета в зависимости от отклонения
    function getColorForDeviation(deviation) {
        const normalizedDeviation = Math.min(1, deviation / maxDeviationForColor); // Нормализуем отклонение от 0 до 1
        const hue = normalizedDeviation * 120; // Преобразуем отклонение в оттенок (от 0 до 120, где 0 - красный, 120 - зеленый)
        return `hsl(${120 - hue}, 100%, 50%)`; // Возвращаем цвет в формате HSL (от зеленого к красному)
    }

    canvas.addEventListener('mousedown', (e) => {
        startDrawing(e.clientX, e.clientY);
    });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        startDrawing(touch.clientX, touch.clientY);
    });

    canvas.addEventListener('mousemove', (e) => {
        draw(e.clientX, e.clientY);
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        draw(touch.clientX, touch.clientY);
    });

    canvas.addEventListener('mouseup', () => {
        endDrawing();
    });

    canvas.addEventListener('touchend', () => {
        endDrawing();
    });

    drawCenter();
</script>

</body>
</html>
